<?php

namespace App\Http\Controllers\Estudiante;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use App\Models\Evaluation;
use App\Models\Result;
use App\Models\Question;

class EstudianteController extends Controller
{
    //METODO PARA MOSTRAR EN LA VISTA DE PRUEBA DE DIAGNOSTICO LA PRUEBA DE DIAGNOSTICO QUE LE PERTENECE AL ESTUDIANTE ACTUAL
    public function pruebadiagnostico(){
        
        //CAPTURAR LA ID DEL USUARIO ACTUAL LOGEADO
        $authUser = auth()->user()->id;

        //EN LA VARIABLE ASSIGNEDEVALUATIONS SE VA A TOMAR SOLO LOS IDS DEL USUARIO ACTUAL Y SUS EXAMENES RELACIONADOS QUE ESTAN EN LA 
        //TABLA EVALUATION_USER Y SE GUARDAN EN UN ARRAY
        $assignedEvaluationsId = DB::table('evaluation_user')->where('user_id', $authUser)->pluck('evaluation_id')->toArray();

        //EN LA VARIABLE EVALUATIONS SE ALMACENA UNA COLECCION DE LA TABLA EVALUATIONS QUE CONTIENE LAS EVALUATIONS QUE LE PERTENENECEN
        //AL USUARIO ACTUAL, CON EL METODO WHEREIN() SE PUEDE POR EJEMPLO: SI TENGO UN ARRAY CON LOS IDS [1,2,3] QUE VAYA COMPARANDO 
        //AL MISMO TIMEPO LOS 3 IDS DEL ARRAY CON EL ID ACTUAL DE LA COLECCION DE ASSIGNEDEVALUATIONS, ENTONCES SI COINCIDE CON ALGUN ID DEL ARRAY
        //SE GUARDA EN LA VARIABLE EVALUATIONS Y SE VA FORMANDO UNA COLECCION DE EVALUATIONS QUE LE PERTENECEN AL ESTUDIANTE ACTUAL
        
        //$evaluations = Evaluation::whereIn('id', $assignedEvaluationsId)->get();
        $evaluations = Evaluation::whereIn('id', $assignedEvaluationsId)->where('type', "D")->get();

        //EN LA VARIABLE ISEVALUATION ASSIGNED SE REVISA SI EN LA TABLA INTERMEDIA EVALUATION_QUIZ EXISTEN REGISTROS DE EXAMENES ASIGNADOS AL USUARIO ACTUAL
        //ESTO SIRVE PARA QUE SI EN EL CASO DE QUE NO TENGA EXAMENES ASIGNADOS, EN LA VISTA DE EVALUACION DE DIAGNOSTICO LE APAREZCA UN MENSAJE
        $isEvaluationAssigned = DB::table('evaluation_user')->where('user_id', $authUser)->exists();

        //EN LA VARIABLE WAS EVALUATIONCOMPLETED SE CONSULTA EN LA TABLA RESULT LOS REGISTROS CUYO CAMPO USER_ID COINCIDAN CON EL ID DEL USUARIO ACTUAL
        //Y A ESOS REGISTROS QUE COINCIDAN, CON EL METODO WHEREIN() SE VA COMPROBANDO SI EL CAMPO EVALUATION_ID DE ESOS REGISTROS COINCIDE CON LOS IDS
        //DE LOS EXAMENES QUE EL USUARIO YA RESOLVIO (POR ESO SE CREA UNA INSTANCIA DEL MODELO EVALUATION Y SE INVOCA AL METODO HASEVALUATIONATTEMPTED PARA COMPROBARLOS)
        //Y CUANDO ENCUENTRE ESOS REGISTROS QUE COINCIDEN, ENTONCES CON EL METODO PLUCK() SOLO VA A SACAR EL CAMPO EVALUATION_ID DE ESOS REGISTROS 
        //Y LOS VA A ALMACENAR EN UN ARRAY
        $wasEvaluationCompleted = Result::where('user_id', $authUser)->whereIn('evaluation_id', (new Evaluation)->hasEvaluationAttempted())->pluck('evaluation_id')->toArray();

        return view('rules.diagnostic', compact('evaluations', 'wasEvaluationCompleted', 'isEvaluationAssigned'));
    }



    //METODO PARA MOSTRAR EN LA VISTA DE PRUEBA DE DIAGNOSTICO LA PRUEBA DE DIAGNOSTICO QUE LE PERTENECE AL ESTUDIANTE ACTUAL
    //METODO MODIFICADO
    public function pruebadiagnosticomod(){

        //CAPTURAR LA ID DEL USUARIO ACTUAL LOGEADO
        $authUser = auth()->user()->id;

        //EN LA VARIABLE ASSIGNEDEVALUATIONSID SE VA A TOMAR SOLO LOS CAMPOS EVALUATION_ID DEL USUARIO ACTUAL QUE ESTEN RELACIONADOS EN LA 
        //TABLA EVALUATION_USER Y SE GUARDAN EN UN ARRAY
        $assignedEvaluationsId = DB::table('evaluation_user')->where('user_id', $authUser)->pluck('evaluation_id')->toArray();

        //EN LA VARIABLE EVALUATIONS SE ALMACENA UNA COLECCION DE LA TABLA EVALUATIONS QUE CONTIENE LAS EVALUATIONS QUE FUERON ASIGNADAS AL USUARIO 
        //ACTUAL, CON EL METODO WHEREIN() SE PUEDE POR EJEMPLO: SI TENGO UN ARRAY CON LOS IDS [1,2,3] QUE VAYA COMPARANDO 
        //AL MISMO TIEMPO LOS 3 IDS DEL ARRAY CON EL ID ACTUAL DE LA COLECCION DE ASSIGNEDEVALUATIONS, ENTONCES SI COINCIDE CON ALGUN ID DEL ARRAY
        //SE GUARDA EN LA VARIABLE EVALUATIONS Y SE VA FORMANDO UNA COLECCION DE EVALUATIONS QUE LE PERTENECEN AL ESTUDIANTE ACTUAL

        //$evaluations = Evaluation::whereIn('id', $assignedEvaluationsId)->get();
        //COMO MEDIANTE ESTE METODO SOLO SE VA A CAPTURAR EL EXAMEN DE DIAGNOSTICO ASIGNADO AL ESTUDIANTE ACTUAL SE LO REALIZA DE ESTA MANERA
        $evaluations = Evaluation::whereIn('id', $assignedEvaluationsId)->where('type', "D")->get();

        //EN LA VARIABLE ISEVALUATIONASSIGNED SE REVISA SI EN LA TABLA INTERMEDIA EVALUATION_QUIZ EXISTEN REGISTROS DE EXAMENES ASIGNADOS AL USUARIO ACTUAL
        //ESTO SIRVEE PARA QUE SI EN EL CASO DE QUE NO TENGA EXAMENES ASIGNADO, EN LA VISTA DE EVALUACION DIAGNOSTICO LE APAREZCA UN MENSAJE
        $isEvaluationAssigned = DB::table('evaluation_user')->where('user_id', $authUser)->exists();


        //EN LA VARIABLE WASEVALUATIONCOMPLETED SE CONSULTA EN LA TABLA RESULTS LOS REGISTROS CUYO CAMPO USER_ID COINCIDAN CON EL ID DEL USUARIO ACTUAL
        //Y A ESOS REGISTROS QUE COINCIDAN, CON EL METODO WHEREIN() SE VA COMPROBANDO SI EL CAMPO EVALUATION_ID DE ESOS REGISTROS COINCIDE CON LOS IDS 
        //DE LOS EXAMENES QUE EL USUARIO YA RESOLVIO (POR ESO SE CREA UNA INSTANCIA DEL MODELO EVALUATION Y SE INVOCA AL METODO HASEVALUATIONATTEMPTED PARA COMPROBARLOS)
        //Y CUANDO ENCUENTRE ESOS REGISTROS QUE COINCIDEN, ENTONCES CON EL METODO PLUCK() SOLO VA A SACAR EL CAMPO EVALUATION_ID DE ESOS REGISTROS
        //Y LOS ALMACENA EN UN ARRAY
        $wasEvaluationCompleted = Result::where('user_id', $authUser)->whereIn('evaluation_id', (new Evaluation)->hasEvaluationAttempted())->pluck('evaluation_id')->toArray();

    

        //ACTUALIZACION, MEDIANTE LA VARIABLE IS EVALUATIONASSIGNED QUE DEVUELVE TRUE SI EL USUARIO ACTUAL TIENE EVALUACIONES ASIGNADAS O FALSE SI NO TIENE
        //SE DECIDEN QUE ENVIAR O QUE NO ENVIAR A LA VISTA, PORQUE SINO DA ERROR
        //SI TIENE EXAMENES ASIGNADOS SE BUSCAR EL EXAMEN ASIGNADO Y LAS PREGUNTAS DE ESA EVALUACION, CASO CONTRARIO SOLO  SE ENVIA A LA VISTA LA VARIABLE
        //ISEVALUATIONASSIGNED
        if($isEvaluationAssigned === true){
            ////////////////////////////////////////////////NUEVO METODO PARA QUE EL USUARIO PUEDA INGRESAR NORMALMENTE A UNA EVALUACION DE DIAGNOSTICO SI NO HA RESPONDIDO TODAS LAS PREGUNTAS

            //EN LA VARIABLE NROPREGUNTASDIAGNOSTICO SE GUARDA EL NUMERO DE PREGUNTAS QUE CONTIENE EL EXAMEN DE DIAGNOSTICO ASIGNADO AL ESTUDIANTE ACTUAL
            //PARA ELLO PRIMERO SE CAPTURA EN UNA VARIABLE EL PRIMER ELEMENTO DE LA VARIABLE EVALUATIONS QUE CONTIENE LA PRUEBA DE DIAGNOSTICO ASIGNADA AL ESTUDIANTE ACTUAL
            $diagnostico = $evaluations->first();
            //DE LA PRUEBA DE DIAGNOSTICO SE CUENTA CUANTAS PREGUNTAS TIENE ESA PRUEBA
            $nropreguntasdiagnostico = count($diagnostico->questions);
            //EN LA VARIABLE PREGUNTASASIGNADASDIAGNOSTICO SE VA A CAPTURAR LOS IDS DE LAS PREGUNTAS DE LA PRUEBA DE EVALUACION DE DIAGNOSTICO ASIGNADA
            $preguntasasignadasDiagnostico = DB::table('questions')->where('evaluation_id', $diagnostico->id)->pluck('id')->toArray();

            //EN LA VARIABLE PREGUNTASRESPONDIDASDIAGNOSTICO SE VA A CAPTURAR LA COLECCION DE PREGUNTAS QUE EL USUARIO HAYA RESPONDIDO Y QUE ESTEN EN LA TABLA RESULTS
            //QUE TENGAN EL MISMO EVALUATION_ID DE LA EVALUACION DE DIAGNOSTICO, QUE TENGAN EL MISMO QUESTION_ID DE LAS PREGUNTAS DE LA EVALUACION DE DIAGNOSTICO 
            //Y QUE TENGAN EL MISMO ID QUE EL USUARIO ACTUAL LOGEADO
            $preguntasrespondidasDiagnostico = DB::table('results')->where('evaluation_id', $diagnostico->id)->where('user_id', $authUser)->whereIn('question_id', $preguntasasignadasDiagnostico)->get();
            //COMO EN LA TABLA RESULTS SE ALMACENAN VARIAS RESPUESTAS SEGUN EL TIPO DE PREGUNTA, POR EJEMPLO LA QUESTION OM SOLO GUARDA 1 REGISTRO EN RESULTS PERO LA QUESTION PC GUARDA 5 REGISTROS EN RESULTS
            //POR LO QUE DE LA COLECCION DE PREGUNTAS RESPONDIDAS QUE VIENE DESDE LA TABLA RESULTS SOLO SE CAPTURA LOS PRIMEROS ELEMENTOS CON QUESTION_ID DIFERENTES
            $resultadospreguntasDiagnostico = $preguntasrespondidasDiagnostico->unique('question_id')->values();

            //EN LA VARIABLE NROPREGUNTASRESPONDIDASDIAGNOSTICO SE GUARDA EL NUMERO DE QUESTIONS RESPONDIDAS SEGUN LA TABLA RESULTS
            $nropreguntasrespondidasDiagnostico = count($resultadospreguntasDiagnostico);

            //AHORA, EN LA VARIABLE DIAGNOSTICOCOMPLETADO QUE ES TIPO BOOLEAN, SE ENVIA TRUE SI EL NUMERO DE QUESTIONS DEL EXAMEN DE DIAGNOSTICO COINCIDE CON EL NUMERO DE QUESTIONS
            //RESPONDIDAS POR EL USUARIO QUE VIENE DE LA TABLA RESULTS, ESTO SIRVE PARA SEGUN SI ES TRUE O FALSE MOSTRAR EL BOTON DE RESPONDER EXAMEN O VER RESULTADOS
            $diagnosticoCompletado = false;

            if($nropreguntasrespondidasDiagnostico === $nropreguntasdiagnostico){
                $diagnosticoCompletado = true;
            }

            //return $diagnosticoCompletado;
            

            return view('rules.diagnostic', compact('evaluations', 'wasEvaluationCompleted', 'isEvaluationAssigned', 'diagnosticoCompletado'));
        }
        else{
            return view('rules.diagnostic', compact('isEvaluationAssigned'));

        }

        


    }


    //METODO PARA MOSTRAR EN LA VISTA DE PRUEBAS DE PRACTICA LA PRUEBAS DE PRACTICA QUE LE PERTENECEN AL ESTUDIANTE ACTUAL
    public function pruebaspractica(){
        
        //CAPTURAR EL ID DEL USUARIO ACTUAL LOGEADO
        $authUser = auth()->user()->id;

        //EN LA VARIABLE ASSIGNEDEVALUATIONS SE VA A TOMAR SOLO LOS IDS DEL USUARIO ACTUAL Y SUS EXAMENES RELACIONADOS QUE ESTAN EN LA TABLA EVALUATION_USER
        //Y SE GUARDAN EN UN ARRAY
        $assignedEvaluationsId = DB::table('evaluation_user')->where('user_id', $authUser)->pluck('evaluation_id')->toArray();

        //EN LA VARIABLE EVALUATIONS SE ALMACENA UNA COLECCION DE LA TABLA EVALUATIONS QUE CONTIENE LAS EVALUATIONS QUE LE PERTENECEN 
        //AL USUARIO ACTUAL, CON EL METODO WHEREIN() SE PUEDE POR EJEMPLO:SI TENGO UN ARRAY CON LOS IDS [1,2,3] QUE VAYA COMPARANDO
        //AL MISMO TIEMPO LOS 3 IDS DEL ARRAY CON EL ID ACTUAL DE LA COLECCION DE ASSIGNEDEVALUATIONS, ENTONCES SI COINCIDE CON ALGUNO ID DEL ARRAY
        //SE GUARDA EN LA VARIABLE EVALUATIONS Y SE VA FORMANDO UNA COLECCION DE EVALUATIONS QUE LE PERTENECEN AL ESTUDIANTE ACTUAL
        $tipos = ["PU", "PD", "PT"];
        $evaluations = Evaluation::whereIn('id', $assignedEvaluationsId)->whereIn('type', $tipos)->get();

        //EN LA VARIABLE ISEVALUATIONASSIGNED SE REVISA SI EN LA TABLA INTERMEDIA EVALUATION_USER EXISTEN REGISTROS DE EXAMENES ASIGNADOS AL USUARIO ACTUAL
        //ESTO SIRVE PARA QUE SI EN EL CASO DE QUE NO TENGA EXAMENES ASIGNADOS, EN LA VISTA DE EVALUACIONES DE PRACTICA LE APAREZCA UN MENSAJE
        $isEvaluationAssigned = DB::table('evaluation_user')->where('user_id', $authUser)->exists();

        //EN LA VARIABLE WASEVALUATIONCOMPLETED SE CONSULTAR EN LA TABLA RESULT LOS REGISTROS CUYO CAMPO USER_UD COINCIDAN CON EL ID DEL USUARIO ACTUAL
        //Y A ESOS REGISTROS QUE COINCIDAN, CON LE METODO WHEREIN() SE VA COMPROBANDO SI EL CAMPO EVALUATION_ID DE ESOS REGISTROS COINCIDE CON LOS IDS
        //DE LOS EXAMENES QUE EL USUARIO YA RESOLVIO (POR EESO SE CREA UNA INSTANCIA DEL MODELO EVALUATION Y SE INVOCA AL METODO HASEVALUATIONATTEMPTED PARA COMPROBARLOS)
        //Y CUANDO ENCUENTREE ESOS REGISTROS QUE COINCIDEN, ENTONCES CON EL METODO PLUCK() SOLO VA A SACAR EL CAMPO EVALUATION_ID DE ESOS REGISTROS
        //Y LOS ALMACENA EN UN ARRAY
        $wasEvaluationCompleted = Result::where('user_id', $authUser)->whereIn('evaluation_id', (new Evaluation)->hasEvaluationAttempted())->pluck('evaluation_id')->toArray();

        return view('rules.practice', compact('evaluations', 'wasEvaluationCompleted', 'isEvaluationAssigned'));
    }



    //METODO PARA MOSTRAR EN LA VISTA LAS PRUEBAS DE PRACTICA QUE LE PERTENECEN AL ESTUDIANTE ACTUAL
    //METODO MODIFICADO
    public function pruebaspracticamod(){

        //CAPTURAR EL ID DEL USUARIO ACTUAL LOGEADO
        $authUser = auth()->user()->id;

        //EN LA VARIABLE ASSIGNEDEVALUATIONS SE VA A TOMAR SOLO LOS IDS DEL USUARIO ACTUAL Y SUS EXAMENES RELACIONADOS QUE ESTAN EN LA TABLA EVALUATION_USER
        //Y SE GUARDAN EN UN ARRAY
        $assignedEvaluationsId = DB::table('evaluation_user')->where('user_id', $authUser)->pluck('evaluation_id')->toArray();

        
        //EN LA VARIABLE EVALUATIONS SE ALMACENA UNA COLECCION DE LA TABLA EVALUATIONS QUE CONTIENE LAS EVALUATIONS QUE LE PERTENECEN 
        //AL USUARIO ACTUAL, CON EL METODO WHEREIN() SE PUEDE POR EJEMPLO: SI TENGO UN ARRAY CON LOS IDS [1,2,3] QUE VAYA COMPARANDO
        //AL MISMO TIEMPO LOS 3 IDS DEL ARRAY CON EL ID ACTUAL DE LA COLECCION DE ASSIGNED EVALUATIONS, ENTONCES SI COINCIDE CON ALGUN ID DEL ARRAY
        //SE GUARDA EN LA VARIABLE EVALUATIONS Y SE VA FORMANDO UNA COLECCION DE EVALUATIONS QUE LE PERTENECEN AL ESTUDIANTE ACTUAL
        $tipos = ["PU", "PD", "PT"];
        $evaluations = Evaluation::whereIn('id', $assignedEvaluationsId)->whereIn('type', $tipos)->get();

        //EN LA VARIABLE ISEVALUATIONASSIGNED SE REVISA SI EN LA TABLA INTERMEDIA EVALUATION_USER EXISTEN REGISTROS DE EXAMENES ASIGNADOS AL USUARIO ACTUAL
        //ESTO SIRVE PARA QUE SI EN EL CASO DE QUE NO TENGA EXAMENES ASIGNADOS, EN LA VISTA DE EVALUACIONES DE PRACTICA LE APAREZCA UN MENSAJE
        $isEvaluationAssigned = DB::table('evaluation_user')->where('user_id', $authUser)->exists();

        //EN LA VARIABLEE WASEVALUATIONCOMPLETED SE CONSULTA EN LA TABLA RESULT LOS REGISTROS CUYO CAMPO USER_ID COINCIDAN CON EL ID DEL USUARIO ACTUAL
        //Y A ESOS REGISTROS QUE COINCIDAN CON EL METODO WHEREIN() SE VA COMPROBANDO SI EL CAMPO EVALUATION_ID DE ESOS REGISTROS COINCIDE CON LOS IDS
        //DE LOS EXAMENES QUE EL USUARIO YA RESOLVIO (POR ESO SE CREA UNA INSTANCIA DEL MODELO EVALUATION Y SE INVOCA AL METODO HASEVALUATIONATTEMPTED PARA COMPROBARLOS)
        //Y CUANDO ENCUENTRE ESOS REGISTROS QUE COINCIDEN, ENTONCES CON EL METODO PLUCK() SOLO VA A SACAR EL CAMPO EVALUATION_ID DE ESOS REGISTROS
        //Y LOS ALMACENA EN UN ARRAY
        $wasEvaluationCompleted = Result::where('user_id', $authUser)->whereIn('evaluation_id', (new Evaluation)->hasEvaluationAttempted())->pluck('evaluation_id')->toArray();

        
        //ACTUALIZACION
        //MEDIANTE LA VARIABLE ISEVALUATIONASSIGNED SI ES TRUE SE REALIZAR EL CODIGO PARA MOSTRAR LAS EVALUACIONES DE PRACTICA AL ESTUDIANTE ACTUAL
        //SI EL ESTUDIANTE NO TIENE EVALUACIONES ASIGNADAS ENTONCES SOLO SE ENVIA LA VARIABLE IS EVALUATIONASSIGNED
        if($isEvaluationAssigned === true){


            ////////////////////////////////////////////////////////NUEVO METODO PARA QUE EL USUARIO PUEDA INGRESAR NORMALMENTE A UNA EVALUACION DE PRACTICA SI NO HA RESPONDIDO TODAS LAS PREGUNTAS

            //PRIMERO SE DEBE VERIFICAR QUE EL USUARIO HAYA RESPONDIDO TODAS LAS PREGUNTAS DE LA EVALUACION DE DIAGNOSTICO ASIGNADA
            //POR ESO PRIMERO SE COMPRUEBA QUE EL NUMERO DE PREGUNTAS DE LA EVALUACION DE DIAGNOSTICO ASIGNADA AL ESTUDIANTE ACTUAL, SEA LA MISMA QUE EL NUMERO DE RESPUESTAS DE LA TABLA RESULTS

            //EN LA VARIABLE COLECCIONDIAGNOSTICO SE CAPTURA EL EXAMEN DE DIAGNOSTICO ASIGNADO AL ESTUDIANTE ACTUAL
            $coleccionDiagnostico = Evaluation::where('id', $assignedEvaluationsId)->where('type', "D")->get();
            //EN LA VARIABLE DIAGNOSTICO SE CAPTURA EL PRIMER ELEMENTO DE LA VARIABLE COLECCIONDIAGNOSTICO QUE CONTIENE LA PRUEBA DE DIAGNOSTICO ASIGNADA AL USUARIO ACTUAL
            $diagnostico = $coleccionDiagnostico->first();
            //EN LA VARIABLE NROPREGUNTASDIAGNOSTICO SE CUENTA CUANTRAS PREGUNTAS TIENE ESA PRUEBA
            $nroPreguntasDiagnostico = count($diagnostico->questions);


            //AHORA SE DEBE CAPTURAR EL NUMERO DE PREGUNTAS RESPONDIDAS POR EL USUARIO A LA PRUEBA DE DIAGNOSTICO QUE ESTA EN LA TABLA RESULTS

            //EN LA VARIABLE PREGUNTASASIGNADASDIAGNOSTICO SE VA A CAPTURAR LOS IDS DE LAS PREGUNTAS DE LA PRUEBA DE EVALUACION DE DIAGNOSTICO ASIGNADA AL USUARIO ACTUAL
            $preguntasAsignadasDiagnostico = DB::table('questions')->where('evaluation_id', $diagnostico->id)->pluck('id')->toArray();
            //EN LA VARIABLE PREGUNTASRESPONDIDASDIAGNOSTICO SE VA A CAPTURAR LA COLECCION DE PREGUNTAS QUE EL USUARIO HAYA RESPONDIDO DE LA PRUEBA DE DIAGNOSTICO Y QUE ESTEN EN LA TABLA RESULTS
            //QUE TENGAN EL MISMO EVALUATION_ID DE LA EVALUACION DE DIAGNOSTICO, QUE TENGAN EL MISMO QUESTION_ID DE LAS PREGUNTAS DE LA EVALUACION DE DIAGNOSTICO
            //Y QUE TENGAN EL MISMO ID QUE EL USUARIO ACTUAL LOGEADO
            $preguntasrespondidasDiagnostico = DB::table('results')->where('evaluation_id', $diagnostico->id)->where('user_id', $authUser)->whereIn('question_id', $preguntasAsignadasDiagnostico)->get();
            //COMO EN LA TABLA RESULTS SEE ALMACENAN VARIAS RESPUESTAS SEGUN EL TIPO DE PREGUNTA, POR EJEMPLO LA QUEESTION OM SOLO GUARDA 1 REGISTRO EN RESULTS PERO LA QUESTION PC GUARDA 5 REGISTROS EN RESULTS
            //POR LO QUE DE LA COLECCION DE PREGUNTAS RESPONDIDAS QUE VIENE DESDE LA TABLA RESULTS, SOLO SE CAPTURA LOS PRIMERO ELEMENTOS CON QUESTION_ID DIFERENTES
            $resultadospreguntasDiagnostico = $preguntasrespondidasDiagnostico->unique('question_id')->values();
            //EN LA VARIABLE NROPREGUNTASRESPONDIDASDIAGNOSTICO SE GUARDA EL NUMERO DE QUESTIONS RESPONDIDAS SEGUN LA TABLA RESULTS
            $nropreguntasrespondidasDiagnostico = count($resultadospreguntasDiagnostico);


            //AHORA, EN LA VARIABLE DIAGNOSTICOCOMPLETADO QUE ES TIPO BOOLEAN, SE ENVIA TRUE SI EL NUMERO DE QUESTIONS DEL EXAMEN DE DIAGNOSTICO COINCIDE CON EL NUMERO DE QUESTIONS
            //RESPONDIDAS POR EL USUARIO QUE VIENE DE LA TABLA RESULTS, ESTO SRIVE PARA SEGUN SI ES TRUE O FALSE QUE SE MUESTREN LOS BOTONES DE INGRESAR AL EXAMEN PARA LOS EXAMENES DE PRACTICA
            $diagnosticoCompletado = false;
            if($nropreguntasrespondidasDiagnostico === $nroPreguntasDiagnostico){
                $diagnosticoCompletado = true;
            }

        
            ///////////////////////VALIDAR SI LA PRUEBA DE PRACTICA TIPO PU HA SIDO COMPLETADA

            //SE DEBE VALIDAR SI LA PRUEBA DE ESCRITURA TIPO PU HA SIDO RESPONDIDA TODAS SUS PREGUNTAS PARA SABER SI SE DEBE MOSTRAR EL BOTON DE INGRESAR AL EXAMEN O VER RESULTADOS

            //PRIMERO SE DEBE CONTAR EL NUMERO DE QUESTIONS ASIGNADAS A LA PRUEBA TIPO PU ASIGNADA AL USUARIO ACTUAL

            //EN LA VARIABLE EVALUACIONPU SE CAPTURA LA PRUEBA PU ASIGNADA AL USUARIO ACTUAL, MEDIANTE LA COLECCION EVALUATIONS QUE CONTIENE LAS EVALUACIONES DE PRACTICA DEL USUARIO ACTUAL
            $evaluacionPU = $evaluations->where('type', "PU");
            //EN LA VARIABLE EVALUACIONUNO SE CAPTURA EL PRIMER ELEMENTO DE LA COLECCION EVALUACIONPU
            $evaluacionUno = $evaluacionPU->first();
            //EN LA VARIABLE NROPREGUNTASEVALUACIOUNO SE CUENTA CUANTAS PREGUNTAS TIENE ESA PRUEBA
            $nropreguntasEvaluacionUno = count($evaluacionUno->questions);

            //AHORA SE DEBE CONTAR EL NUMERO DE PREGUNTAS RESPONDIDAS POR EL USUARIO A LA EVALUACIONUNO
            
            //EN LA VARIABLE PREGUNTASASIGNADASUNO SE VA A CAPTURAR LOS IDS DE LAS PREGUNTAS DE LA PRUEBA UNO ASIGNADA
            $preguntasasignadasUno = DB::table('questions')->where('evaluation_id', $evaluacionUno->id)->pluck('id')->toArray();
            //EN LA VARIABLE PREGUNTASRESPONDIDASUNO SE VA A CAPTURAR LA COLECCION DE PREGUNTAS QUE EL USUARIO HAYA RESPONDIDO Y QUE ESTEN EN LA TABLA RESULTS
            //QUE TENGAN EL MISMO EVALUATION_ID DE LA EVALUACIONUNO, QUE TENGAN EL MISMO QUESTION_ID DE LAS PREGUNTAS DE LA EVALUACION UNO Y QUE TENGAN EL MISMO
            //USER_ID QUE EL USUARIO ACTUAL LOGEADO
            $preguntasrespondidasUno = DB::table('results')->where('evaluation_id', $evaluacionUno->id)->where('user_id', $authUser)->whereIn('question_id', $preguntasasignadasUno)->get();
            //COMO EN LA TABLA RESULTS SE ALMACENAN VARIAS RESPUESTAS SEGUN EL TIPO DE PREGUNTA, POR EJEMPLO LA QUESTION OM SOLO GUARDA 1 REGISTRO EN RESULTS, PERO LA QUESTION PC GUARDA 5 REGISTROS EN RESULTS
            //POR LO QUE DE LA COLECCION DE PREGUNTAS RESPONDIDAS QUE VIENE DESDE LA TABLA RESULTS SOLO SE CAPTURA LOS PRIMEROS ELEMENTOS CON QUESTION_ID DIFERENTES
            $resultadospreguntasUno = $preguntasrespondidasUno->unique('question_id')->values();
            //EN LA VARIABLE NROPREGUNTASRESPONDIDASUNO SE GUARDA EL NUMERO DE QUESTIONS RESPONDIDAS SEGUN LA TABLA RESULTS
            $nropreguntasrespondidasUno = count($resultadospreguntasUno);


            //AHORA, EN LA VARIABLE UNOCOMPLETADO QUE ES TIPO BOOLEAN, SE ENVIA TRUE SI EL NUMERO DE QUESTIONS DEL EXAMEN UNO COINCIDE CON EL NUMERO DE QUESTIONS RESPONDIDAS
            //POR EL USUARIO QUE VIENE DE LA TABLA RESULTS, ESTO SIRVE PARA SEGUN SI ES TRUE O FALSE MOSTRAR EL BOTON DE RESPONDER EXAMEN O VER RESULTADOS
            $unoCompletado = false;
            if($nropreguntasrespondidasUno === $nropreguntasEvaluacionUno){
                $unoCompletado = true;
            }



            ////////////////////////////////////////VALIDAR SI LA PRUEBA DE PRACTICA TIPO PD HA SIDO COMPLETADA

            //SE DEBE VALIDAR SI LA PRUEBA DE AUDIO TIPO PD HA SIDO RESPONDIDA TODAS SUS PREGUNTAS PARA SABER SI SE DEBE MOSTRAR EL BOTON DE INGRESAR AL EXAMEN O VER RESULTADOS

            //PRIMERO SE DEBE CONTAR EL NUMERO DE QUESTIONS ASIGNADAS A LA PRUEBA TIPO PD ASIGNADA AL USUARIO ACTUAL

            //EN LA VARIABLE EVALUACIONPD SE CAPTURA LA PRUEBA PD ASIGNADA AL USUARIO ACTUAL, MEDIANTE LA COLECCION EVALUATIONS QUE CONTIENE LAS EVALUACIONES DE PRACTICA DEL USUARIO ACTUAL
            $evaluacionPD = $evaluations->where('type', "PD");
            //EN LA VARIABLE EVALUACIONDOS SE CAPTURA EL PRIMER ELEMENTO DE LA COLECCION EVALUACIONPD
            $evaluacionDos = $evaluacionPD->first();
            //EN LA VARIABLE NROPREGUNTASEVALUACIONDOS SE CUENTA CUANTAS PREGUNTAS TIENE ESA PRUEBA
            $nropreguntasEvaluacionDos = count($evaluacionDos->questions);

            //AHORA SE DEBE CONTAR EL NUMERO DE PREGUNTAS RESPONDIDAS POR EL USUARIO A LA EVALUACIONDOS

            //EN LA VARIABLE PREGUNTASASIGNADASDOS SE VA A CAPTURAR LOS IDS DE LAS PREGUNTAS DE LA PRUEBA DOS ASIGNADA
            $preguntasasignadasDos = DB::table('questions')->where('evaluation_id', $evaluacionDos->id)->pluck('id')->toArray();
            //EN LA VARIABLE PREGUNTASRESPONDIDASDOS SE VA A CAPTURAR LA COLECCION DE PREGUNTAS QUE EL USUARIO HAYA RESPONDIDO Y QUE ESTEN EN LA TABLA RESULTS
            //QUE TENGAN EL MISMO EVALUATION_ID DE LA EVALUACIONDOS, QUE TENGAN EL MISMO QUESTION_ID DE LAS PREGUNTAS DE LA EVALUACION DOS Y QUE TENGAN EL MISMO
            //USER_ID QUE EL USUARIO ACTUAL LOGEADO
            $preguntasrespondidasDos = DB::table('results')->where('evaluation_id', $evaluacionDos->id)->where('user_id', $authUser)->whereIn('question_id', $preguntasasignadasDos)->get();
            //COMO EN LA TABLA RESULTS SE ALMACENAN VARIAS RESPUESTAS SEGUN EL TIPO DE PREGUNTA, POR EJEMPLO LA QUESTION OM SOLO GUARDA 1 REGISTRO EN RESULTS, PERO LA QUESTION PC GUARDA 5 REGISTROS EN RESULTS
            //POR LO QUE DE LA COLECCION DE PREGUNTAS RESPONDIDAS QUE VIENE DESDE LA TABLA RESULTS SOLO SE CAPTURA LOS PRIMEROS ELEMENTOS CON QUESTION_ID DIFERENTES
            $resultadospreguntasDos = $preguntasrespondidasDos->unique('question_id')->values();
            //EN LA VARIABLE NROPREGUNTASRESPONDIASDOS SE GUARDA EL NUMERO DE QUESTIONS RESPONDIDAS SEGUN LA TABLA RESULTS
            $nropreguntasrespondidasDos = count($resultadospreguntasDos);


            //AHORA, EN LA VARIABLE DOSCOMPLETADO QUE ES TIPO BOOLEAN SE ENVIA TRUE SI EL NUMERO DE QUESTIONS DEL EXAMENUNO COINCIDE CON EL NUMERO DE QUEESTIONS RESPONDIDAS
            //POR EL USUARIO QUE VIENE DE LA TABLA RESULTS, ESTO SIRVE PARA SEGUN SI ES TRUE O FALSE, MOSTRAR EL BOTON DE RESPONDER EXAMEN O VER RESULTADOS
            $dosCompletado = false;
            if($nropreguntasrespondidasDos === $nropreguntasEvaluacionDos){
                $dosCompletado = true;
            }




            /////////////////////////////////////////////////////VALIDAR SI LA PRUEBA DE PRACTICA TIPO PT HA SIDO COMPLETADA

            //SE DEBE VALIDAR SI LA PRUEBA DE VISION TIPO PT HA SIDO RESPONDIDA TODAS SUS PREGUNTAS PARA SABER SI SE DEBE MOSTRAR EL BOTON DE INGRESAR AL EXAMEN O VER RESULTADOS

            //PRIMERO SE DEBE CONTAR EL NUMERO DE QUESTIONS ASIGNADAS A LA PRUEBA TIPO PT ASIGNADA AL USUARIO ACTUAL

            //EN LA VARIABLEE EVALUACIONPT SE CAPTURA LA PRUEBA PT ASIGNADA AL USUARIO ACTUAL, MEDIANTE LA COLECCION EVALUATIONS QUE CONTIENE LAS EVALUACIONS DE PRACTICA DEL USUARIO ACTUAL
            $evaluacionPT = $evaluations->where('type', "PT");
            //EN LA VARIABLE EVALUACIONTRES SE CAPTURA EL PRIMER ELEMENTO DE LA COLECCION EVALUACIONPT
            $evaluacionTres = $evaluacionPT->first();
            //EN LA VARIABLE NROPREGUNTASEVALUACIONTRES SE CUENTA CUANTAS PREGUNTAS TIENE ESA PRUEBA
            $nropreguntasEvaluacionTres = count($evaluacionTres->questions);

            //AHORA SE DEBE CONTAR EL NUMERO DE PREGUNTAS RESPONDIDAS POR EL USUARIO A LA EVALUACIONTRES

            //EN LA VARIABLE PREGUNTASASIGNADASTRES SE VA A CAPTURAR LOS IDS DE LAS PREGUNTAS DE LA PRUEBA TRES ASIGNADA
            $preguntasasignadasTres = DB::table('questions')->where('evaluation_id', $evaluacionTres->id)->pluck('id')->toArray();
            //EN LA VARIABLE PREGUNTASRESPONDIDASTRES SE VA A CAPTURAR LA COLECCION DE PREGUNTAS QUE EL USUARIO HAYA RESPONDIDO Y QUE ESTEN EN LA TABLA RESULTS
            //QUE TENGAN EL MISMO EVALUATION_ID DE LA EVALUACION TRES, QUE TENGAN EL MISMO QUESTION_ID DE LAS PREGUNTAS DE LA EVALUACION TRES Y QUE TENGAN EL MISMO
            //USER_ID QUE EL USUARIO ACTUAL LOGEADO
            $preguntasrespondidasTres = DB::table('results')->where('evaluation_id', $evaluacionTres->id)->where('user_id', $authUser)->whereIn('question_id', $preguntasasignadasTres)->get();
            //COMO EN LA TABLA RESULTS SE ALMACENAN VARIAS RESPUESTAS SEGUN EL TIPO DE PREGUNTA, POR EJEMPLO LA QUESTION OM GUARDA 1 REGISTRO EN RESULTS, PERO LA QUESTION PC GUARDA 5 REGISTROS EN RESULTS
            //POR LO QUE DE LA COLECCION DE PREGUNTAS RESPONDIDAS QUE VIENE DESDE LA TABLA RESULTS SOLO SE CAPTURA LOS PRIMEROS ELEMENTOS CON QUESTION_ID DIFERENTES
            $resultadospreguntasTres = $preguntasrespondidasTres->unique('question_id')->values();
            //EN LA VARIABLE NROPREGUNTASRESPONDIDASTRES SE GUARDA EL NUMERO DE QUESTIONS RESPONDIDAS SEGUN LA TABLA RESULTS
            $nropreguntasrespondidasTres = count($resultadospreguntasTres);


            //AHORA, EN LA VARIABLE TRESCOMPLETADO QUE ES TIPO BOOLEAN SE ENVIA TRUE SI EL NUMERO DE QUESTIONS DEL EXAMEN TRES COINCIDE CON EL NUMERO DE QUESTIONS RESPONDIDAS
            //POR EL USUARIO QUE VIENE DE LA TABLA RESULTS, ESTO SIRVE PARA SEGUN SI ES TRUE O FALSE, MOSTRAR EL BOTON DE RESPONDER EXAMEN O VER RESULTADOS
            $tresCompletado = false;
            if($nropreguntasrespondidasTres === $nropreguntasEvaluacionTres){
                $tresCompletado = true;
            }

            //return $tresCompletado;

            return view('rules.practice', compact('evaluations', 'wasEvaluationCompleted', 'isEvaluationAssigned', 'diagnosticoCompletado', 'unoCompletado', 'dosCompletado', 'tresCompletado', 'diagnostico'));


        }else{
            return view('rules.practice', compact('isEvaluationAssigned'));
        }


    }


    //METODO PARA MOSTRAR EN LA VISTA DE EVALUACION FINAL LA EVALUACION FINAL DE DIAGNOSTICO QUE LE PERTENECE AL ESTUDIANTE ACTUAL
    public function pruebafinal(){

        //CAPTURAR EL ID DEL USUARIO ACTUAL LOGEADO
        $authUser = auth()->user()->id;

        //EN LA VARIABLE ASSIGNEDEVALUATIONS SE VA A TOMAR SOLO LOS IDS DEL USUARIO ACTUAL Y SUS EXAMENES RELACIONADOS QUE ESTAN EN LA
        //TABLA EVALUATION_USER Y SE GUARDAN EN UN ARRAY
        $assignedEvaluationsId = DB::table('evaluation_user')->where('user_id', $authUser)->pluck('evaluation_id')->toArray();


        //EN LA VARIABLE EVALUATION SE ALMACENA UNA COLECCION DE LA TABLA EVALUATIONS QUE CONTIENE LAS EVALUATIONS QUE LE PERTENECEN
        //AL USUARIO ACTUAL, CON EL METODO WHEREIN() SE PUEDE POR EJEMPLO: SI TENGO UN ARRAY CON LOS IDS [1,2,3] QUE VAYA COMPARANDO
        //AL MISMO TIEMPO LOS 3 IDS DEL ARRAY CON EL ID ACTUAL DE LA COLECCION DE ASSIGNEDEVALUATIONSID, ENTONCES SI COINCIDE ALGUN REGISTRO DE
        //EVALUATIONS CON ALGUN ID DEL ARRAY ASSIGNEDEVALUATIONSID, SE GUARDA EN LA VARIABLE EVALUATIONS Y SE VA FORMANDO UNA COLECCION DE EVALUATIONS
        //QUE LE PERTENECEN AL USUARIO ACTUAL
        $evaluations = Evaluation::whereIn('id', $assignedEvaluationsId)->where('type', "F")->get();

        //EN LA VARIABLE ISEVALUATIONASSIGNED SE REVISA SI EN LA TABLA INTERMEDIA EVALUATION_USER EXISTEN REGISTROS DE EXAMENES ASIGNADOS AL USUARIO
        //ACTUAL , ESTO SIRVE PARA QUE SI EN EL CASO DE QUE NO TENGA EXAMENES ASIGNADOS, EN LA VISTA DE EVALUACION FINAL LE APAREZCA UN MENSAJE
        $isEvaluationAssigned = DB::table('evaluation_user')->where('user_id', $authUser)->exists();

        //EN LA VARIABLE WASEVALUATIONCOMPLETED SE CONSULTA EN LA TABLA RESULT LOS REGISTROS CUYO CAMPO USER_ID COINCIDAN CON EL ID DEL USUARIO ACTUAL
        //Y A ESOS REGISTROS QUE COINCIDAN, CON EL METODO WHEREIN() SE VA COMPROBANDO SI EL CAMPO EVALUATION_ID DE ESOS REGISTROS COINCIDE CON LOS IDS
        //DE LOS EXAMENES QUE EL USUARIO YA RESOLVIO (POR ESO SE CREA UNA INSTANCIA DEL MODELO EVALUATION Y SE INVOCA AL METODO HASEVALUATIONATTEMPTED PARA COMPROBARLOS)
        //Y CUANDO ENCUENTRE ESOS REGISTROS QUE COINCIDEN, ENTONCES CON EL METODO PLUCK() SOLO VA A SACAR EL CAMPO EVALUATION_ID DE ESOS REGISTROS
        //Y LOS VA A ALMACENAR EN UN ARRAY
        $wasEvaluationCompleted = Result::where('user_id', $authUser)->whereIn('evaluation_id', (new Evaluation)->hasEvaluationAttempted())->pluck('evaluation_id')->toArray();

        return view('rules.final', compact('evaluations', 'wasEvaluationCompleted', 'isEvaluationAssigned'));
    }



    //METODO PARA MOSTRAR EN LA VISTA DE EVALUACION FINAL LA EVALUACION FINAL QUE LE PERTENECE AL ESTUDIANTE ACTUAL
    //METODO MODIFICADO

    public function pruebafinalmod(){

        //CAPTURAR EL ID DEL USUARIO ACTUAL LOGEADO
        $authUser = auth()->user()->id;

        //EN LA VARIABLE ASSIGNEDEVALUATIONS SE VA A TOMAR SOLO LOS IDS DEL USUARIO ACTUAL Y SUS EXAMENES RELACIONADOS QUE ESTAN EN LA TABLA
        //EVALUATION_USER Y SE GUARDAN EN UN ARRAY
        $assignedEvaluationsId = DB::table('evaluation_user')->where('user_id', $authUser)->pluck('evaluation_id')->toArray();

        //EN LA VARIABLE EVALUATION SE ALMACENA UNA COLECCION DE LA TABLA EVALUATIONS QUE CONTIENE LAS EVALUATIONS QUE LE PERTENECEN 
        //AL USUARIO ACTUAL, CON EL METODO WHEREIN() SE PUEDE POR EJEMPLO: SI TENGO UN ARRAY CON LOS IDS [1,2,3] QUE VAYA COMPARANDO
        //AL MISMO TIEMPO LOS 3 IDS DEL ARRAY CON EL ID ACTUAL DE LA COLECCION DE ASSIGNEDEVALUATIONSID, ENTONCES SI COINCIDE ALGUN REGISTRO DE
        //EVALUATIONS CON ALGUN ID DEL ARRAY ASSIGNEDEVALUATIONSID, SE GUARDA EN LA VARIABLE EVALUATIONS Y SE VA FORMANDO UNA COLECCION DE EVALUATIONS
        //QUE LE PERTENECEN AL USUARIO ACTUAL
        $evaluations = Evaluation::whereIn('id', $assignedEvaluationsId)->where('type', "F")->get();

        //EN LA VARIABLE ISEVALUATIONASSIGNED SE REVISA SI EN LA TABLA INTERMEDIA EVALUATION_USER EXISTEN REGISTROS DE EXAMENES ASIGNADOS AL USUARIO
        //ACTUAL, ESTO SIRVE PARA QUE SI EN EL CASO DE QUE NO TENGA EXAMENES ASIGNADOS, EN LA VISTA DE EVALUACION FINAL LE APAREZCA UN MENSAJE
        $isEvaluationAssigned = DB::table('evaluation_user')->where('user_id', $authUser)->exists();

        //EN LA VARIABLE WASEVALUATIONCOMPLETED SE CONSULTA EN LA TABLA RESULT LOS REGISTROS CUYO CAMPO USER_ID COINCIDAN CON EL ID DEL USUARIO ACTUAL
        //Y A ESOS REGISTROS QUE COINCIDAN, CON EL METODO WHEREIN() SE VA COMPROBANDO SI EL CAMPO EVALUATION_ID DE ESOS REGISTROS COINCIDE CON LOS IDS 
        //DE LOS EXAMENEES QUE EL USUARIO YA RESOLVIO (POR ESO SE CREA UNA INSTANCIA DEL MODELO EVALUATION Y SE INVOCA AL METODO HASEEVALUATIONATTEMPTED PARA COMPROBARLOS)
        //Y CUANDO ENCUENTRE ESOS REGISTROS QUE COINCIDEN, ENTONCES CON EL METODO PLUCK() SOLO VA A SACAR EL CAMPO EVALUATION_ID DE ESOS REGISTROS
        //Y LOS VA A ALMACENAR EN UN ARRAY
        $wasEvaluationCompleted = Result::where('user_id', $authUser)->whereIn('evaluation_id', (new Evaluation)->hasEvaluationAttempted())->pluck('evaluation_id')->toArray();

        //ACTUALIZACION
        //SI LA VARIABLE ISEVALUATIONASSIGNED ES TRUE ENTONCES QUE SE MUESTRA LA EVALUACION FINAL Y LAS PREGUNTAS CORRESPONDIENTES
        //SI NO TIENE EVALUACION ASIGNADA ENTONCES EN LA VISTA SOLO SE MUESTRA UN MENSAJE
        if($isEvaluationAssigned === true){

            /////////////////////////////////////////////////////////////MUEVO METODO PARA QUE EL USUARIO PUEDA INGRESAR A LA EVALUACION FINAL 

            //PRIMERO SE DEBE VERIFICAR QUE EL USUARIO HAYA RESPONDIDO TODAS LAS PREGUNTAS DE LAS EVALUACIONES DE DIAGNOSTICO, PU, PD Y PT PARA QUE PUEDA INGRESAR A LA EVALUACION FINAL

            //////////////////////////VERIFICAR QUE EL USUARIO HAYA RESPONDIDO LA PRUEBA DE DIAGNOSTICO

            //PRIMERO SE DEBE VERIFICAR QUE EL USUARIO HAYA RESPONDIDO TODAS LAS PREGUNTAS DE LA EVALUACION DE DIAGNOSTICO ASIGNADA
            //POR ESO PRIMERO SE COMPRUEBA QUE EL NUMERO DE PREGUNTAS DE LA EVALUACION DE DIAGNOSTICO ASIGNADA AL ESTUDIANTE ACTUAL, SEA LA MISMA QUE EL NUMERO DE RESPUESTAS DE LA TABLA RESULTS

            //EN LA VARIABLE COLECCIONDIAGNOSTICO SE CAPTURA EL EXAMEN DE DIAGNOSTICO ASIGNADO AL ESTUDIANTE ACTUAL
            $coleccionDiagnostico = Evaluation::where('id', $assignedEvaluationsId)->where('type', "D")->get();
            //EN LA VARIABLE DIAGNOSTICO SE CAPTURA EL PRIMER ELEMENTO DE LA VARIABLE COLECCIONDIAGNOSTICO QUE CONTIENE LA PRUEBA DE DIAGNOSTICO ASIGNADA AL USUARIO ACTUAL
            $diagnostico = $coleccionDiagnostico->first();
            //EN LA VARIABLE NROPREGUNTASDIAGNOSTICO SE CUENTA CUANTRAS PREGUNTAS TIENE ESA PRUEBA
            $nroPreguntasDiagnostico = count($diagnostico->questions);


            //AHORA SE DEBE CAPTURAR EL NUMERO DE PREGUNTAS RESPONDIDAS POR EL USUARIO A LA PRUEBA DE DIAGNOSTICO QUE ESTA EN LA TABLA RESULTS

            //EN LA VARIABLE PREGUNTASASIGNADASDIAGNOSTICO SE VA A CAPTURAR LOS IDS DE LAS PREGUNTAS DE LA PRUEBA DE EVALUACION DE DIAGNOSTICO ASIGNADA AL USUARIO ACTUAL
            $preguntasAsignadasDiagnostico = DB::table('questions')->where('evaluation_id', $diagnostico->id)->pluck('id')->toArray();
            //EN LA VARIABLE PREGUNTASRESPONDIDASDIAGNOSTICO SE VA A CAPTURAR LA COLECCION DE PREGUNTAS QUE EL USUARIO HAYA RESPONDIDO DE LA PRUEBA DE DIAGNOSTICO Y QUE ESTEN EN LA TABLA RESULTS
            //QUE TENGAN EL MISMO EVALUATION_ID DE LA EVALUACION DE DIAGNOSTICO, QUE TENGAN EL MISMO QUESTION_ID DE LAS PREGUNTAS DE LA EVALUACION DE DIAGNOSTICO
            //Y QUE TENGAN EL MISMO ID QUE EL USUARIO ACTUAL LOGEADO
            $preguntasrespondidasDiagnostico = DB::table('results')->where('evaluation_id', $diagnostico->id)->where('user_id', $authUser)->whereIn('question_id', $preguntasAsignadasDiagnostico)->get();
            //COMO EN LA TABLA RESULTS SEE ALMACENAN VARIAS RESPUESTAS SEGUN EL TIPO DE PREGUNTA, POR EJEMPLO LA QUEESTION OM SOLO GUARDA 1 REGISTRO EN RESULTS PERO LA QUESTION PC GUARDA 5 REGISTROS EN RESULTS
            //POR LO QUE DE LA COLECCION DE PREGUNTAS RESPONDIDAS QUE VIENE DESDE LA TABLA RESULTS, SOLO SE CAPTURA LOS PRIMERO ELEMENTOS CON QUESTION_ID DIFERENTES
            $resultadospreguntasDiagnostico = $preguntasrespondidasDiagnostico->unique('question_id')->values();
            //EN LA VARIABLE NROPREGUNTASRESPONDIDASDIAGNOSTICO SE GUARDA EL NUMERO DE QUESTIONS RESPONDIDAS SEGUN LA TABLA RESULTS
            $nropreguntasrespondidasDiagnostico = count($resultadospreguntasDiagnostico);


            //AHORA, EN LA VARIABLE DIAGNOSTICOCOMPLETADO QUE ES TIPO BOOLEAN, SE ENVIA TRUE SI EL NUMERO DE QUESTIONS DEL EXAMEN DE DIAGNOSTICO COINCIDE CON EL NUMERO DE QUESTIONS
            //RESPONDIDAS POR EL USUARIO QUE VIENE DE LA TABLA RESULTS, ESTO SRIVE PARA SEGUN SI ES TRUE O FALSE QUE SE MUESTREN LOS BOTONES DE INGRESAR AL EXAMEN PARA LOS EXAMENES DE PRACTICA
            $diagnosticoCompletado = false;
            if($nropreguntasrespondidasDiagnostico === $nroPreguntasDiagnostico){
                $diagnosticoCompletado = true;
            }


            //////////////////////////////////////////////////////////////////ANTES DE VALIDAR LAS PRUEBAS DE PRACTICA

            //SE DEBE CREAR LA VARIABLE EVALUATIONSPRACTICA QUE CONTIENE LAS 3 PRUEBAS DE PRACTICA ASIGNADAS AL USUARIO ACTUAL

            //EN LA VARIABLE EVALUATIONS SE ALMACENA UNA COLECCION DE LA TABLA EVALUATIONS QUE CONTIENE LAS EVALUATIONS QUE LE PERTENECEN 
            //AL USUARIO ACTUAL, CON EL METODO WHEREIN() SE PUEDE POR EJEMPLO: SI TENGO UN ARRAY CON LOS IDS [1,2,3] QUE VAYA COMPARANDO
            //AL MISMO TIEMPO LOS 3 IDS DEL ARRAY CON EL ID ACTUAL DE LA COLECCION DE ASSIGNED EVALUATIONS, ENTONCES SI COINCIDE CON ALGUN ID DEL ARRAY
            //SE GUARDA EN LA VARIABLE EVALUATIONS Y SE VA FORMANDO UNA COLECCION DE EVALUATIONS QUE LE PERTENECEN AL ESTUDIANTE ACTUAL
            $tipos = ["PU", "PD", "PT"];
            $evaluationspractica = Evaluation::whereIn('id', $assignedEvaluationsId)->whereIn('type', $tipos)->get();


            ///////////////////////VALIDAR SI LA PRUEBA DE PRACTICA TIPO PU HA SIDO COMPLETADA

            //SE DEBE VALIDAR SI LA PRUEBA DE ESCRITURA TIPO PU HA SIDO RESPONDIDA TODAS SUS PREGUNTAS PARA SABER SI SE DEBE MOSTRAR EL BOTON DE INGRESAR AL EXAMEN O VER RESULTADOS

            //PRIMERO SE DEBE CONTAR EL NUMERO DE QUESTIONS ASIGNADAS A LA PRUEBA TIPO PU ASIGNADA AL USUARIO ACTUAL

            //EN LA VARIABLE EVALUACIONPU SE CAPTURA LA PRUEBA PU ASIGNADA AL USUARIO ACTUAL, MEDIANTE LA COLECCION EVALUATIONS QUE CONTIENE LAS EVALUACIONES DE PRACTICA DEL USUARIO ACTUAL
            $evaluacionPU = $evaluationspractica->where('type', "PU");
            //EN LA VARIABLE EVALUACIONUNO SE CAPTURA EL PRIMER ELEMENTO DE LA COLECCION EVALUACIONPU
            $evaluacionUno = $evaluacionPU->first();
            //EN LA VARIABLE NROPREGUNTASEVALUACIOUNO SE CUENTA CUANTAS PREGUNTAS TIENE ESA PRUEBA
            $nropreguntasEvaluacionUno = count($evaluacionUno->questions);


            //AHORA SE DEBE CONTAR EL NUMERO DE PREGUNTAS RESPONDIDAS POR EL USUARIO A LA EVALUACIONUNO
            
            //EN LA VARIABLE PREGUNTASASIGNADASUNO SE VA A CAPTURAR LOS IDS DE LAS PREGUNTAS DE LA PRUEBA UNO ASIGNADA
            $preguntasasignadasUno = DB::table('questions')->where('evaluation_id', $evaluacionUno->id)->pluck('id')->toArray();
            //EN LA VARIABLE PREGUNTASRESPONDIDASUNO SE VA A CAPTURAR LA COLECCION DE PREGUNTAS QUE EL USUARIO HAYA RESPONDIDO Y QUE ESTEN EN LA TABLA RESULTS
            //QUE TENGAN EL MISMO EVALUATION_ID DE LA EVALUACIONUNO, QUE TENGAN EL MISMO QUESTION_ID DE LAS PREGUNTAS DE LA EVALUACION UNO Y QUE TENGAN EL MISMO
            //USER_ID QUE EL USUARIO ACTUAL LOGEADO
            $preguntasrespondidasUno = DB::table('results')->where('evaluation_id', $evaluacionUno->id)->where('user_id', $authUser)->whereIn('question_id', $preguntasasignadasUno)->get();
            //COMO EN LA TABLA RESULTS SE ALMACENAN VARIAS RESPUESTAS SEGUN EL TIPO DE PREGUNTA, POR EJEMPLO LA QUESTION OM SOLO GUARDA 1 REGISTRO EN RESULTS, PERO LA QUESTION PC GUARDA 5 REGISTROS EN RESULTS
            //POR LO QUE DE LA COLECCION DE PREGUNTAS RESPONDIDAS QUE VIENE DESDE LA TABLA RESULTS SOLO SE CAPTURA LOS PRIMEROS ELEMENTOS CON QUESTION_ID DIFERENTES
            $resultadospreguntasUno = $preguntasrespondidasUno->unique('question_id')->values();
            //EN LA VARIABLE NROPREGUNTASRESPONDIDASUNO SE GUARDA EL NUMERO DE QUESTIONS RESPONDIDAS SEGUN LA TABLA RESULTS
            $nropreguntasrespondidasUno = count($resultadospreguntasUno);

            //AHORA, EN LA VARIABLE UNOCOMPLETADO QUE ES TIPO BOOLEAN, SE ENVIA TRUE SI EL NUMERO DE QUESTIONS DEL EXAMEN UNO COINCIDE CON EL NUMERO DE QUESTIONS RESPONDIDAS
            //POR EL USUARIO QUE VIENE DE LA TABLA RESULTS, ESTO SIRVE PARA SEGUN SI ES TRUE O FALSE MOSTRAR EL BOTON DE RESPONDER EXAMEN O VER RESULTADOS
            $unoCompletado = false;
            if($nropreguntasrespondidasUno === $nropreguntasEvaluacionUno){
                $unoCompletado = true;
            }



            ////////////////////////////////////////VALIDAR SI LA PRUEBA DE PRACTICA TIPO PD HA SIDO COMPLETADA

            //SE DEBE VALIDAR SI LA PRUEBA DE AUDIO TIPO PD HA SIDO RESPONDIDA TODAS SUS PREGUNTAS PARA SABER SI SE DEBE MOSTRAR EL BOTON DE INGRESAR AL EXAMEN O VER RESULTADOS

            //PRIMERO SE DEBE CONTAR EL NUMERO DE QUESTIONS ASIGNADAS A LA PRUEBA TIPO PD ASIGNADA AL USUARIO ACTUAL

            //EN LA VARIABLE EVALUACIONPD SE CAPTURA LA PRUEBA PD ASIGNADA AL USUARIO ACTUAL, MEDIANTE LA COLECCION EVALUATIONS QUE CONTIENE LAS EVALUACIONES DE PRACTICA DEL USUARIO ACTUAL
            $evaluacionPD = $evaluationspractica->where('type', "PD");
            //EN LA VARIABLE EVALUACIONDOS SE CAPTURA EL PRIMER ELEMENTO DE LA COLECCION EVALUACIONPD
            $evaluacionDos = $evaluacionPD->first();
            //EN LA VARIABLE NROPREGUNTASEVALUACIONDOS SE CUENTA CUANTAS PREGUNTAS TIENE ESA PRUEBA
            $nropreguntasEvaluacionDos = count($evaluacionDos->questions);

            //AHORA SE DEBE CONTAR EL NUMERO DE PREGUNTAS RESPONDIDAS POR EL USUARIO A LA EVALUACIONDOS

            //EN LA VARIABLE PREGUNTASASIGNADASDOS SE VA A CAPTURAR LOS IDS DE LAS PREGUNTAS DE LA PRUEBA DOS ASIGNADA
            $preguntasasignadasDos = DB::table('questions')->where('evaluation_id', $evaluacionDos->id)->pluck('id')->toArray();
            //EN LA VARIABLE PREGUNTASRESPONDIDASDOS SE VA A CAPTURAR LA COLECCION DE PREGUNTAS QUE EL USUARIO HAYA RESPONDIDO Y QUE ESTEN EN LA TABLA RESULTS
            //QUE TENGAN EL MISMO EVALUATION_ID DE LA EVALUACIONDOS, QUE TENGAN EL MISMO QUESTION_ID DE LAS PREGUNTAS DE LA EVALUACION DOS Y QUE TENGAN EL MISMO
            //USER_ID QUE EL USUARIO ACTUAL LOGEADO
            $preguntasrespondidasDos = DB::table('results')->where('evaluation_id', $evaluacionDos->id)->where('user_id', $authUser)->whereIn('question_id', $preguntasasignadasDos)->get();
            //COMO EN LA TABLA RESULTS SE ALMACENAN VARIAS RESPUESTAS SEGUN EL TIPO DE PREGUNTA, POR EJEMPLO LA QUESTION OM SOLO GUARDA 1 REGISTRO EN RESULTS, PERO LA QUESTION PC GUARDA 5 REGISTROS EN RESULTS
            //POR LO QUE DE LA COLECCION DE PREGUNTAS RESPONDIDAS QUE VIENE DESDE LA TABLA RESULTS SOLO SE CAPTURA LOS PRIMEROS ELEMENTOS CON QUESTION_ID DIFERENTES
            $resultadospreguntasDos = $preguntasrespondidasDos->unique('question_id')->values();
            //EN LA VARIABLE NROPREGUNTASRESPONDIASDOS SE GUARDA EL NUMERO DE QUESTIONS RESPONDIDAS SEGUN LA TABLA RESULTS
            $nropreguntasrespondidasDos = count($resultadospreguntasDos);

            //AHORA, EN LA VARIABLE DOSCOMPLETADO QUE ES TIPO BOOLEAN SE ENVIA TRUE SI EL NUMERO DE QUESTIONS DEL EXAMENUNO COINCIDE CON EL NUMERO DE QUEESTIONS RESPONDIDAS
            //POR EL USUARIO QUE VIENE DE LA TABLA RESULTS, ESTO SIRVE PARA SEGUN SI ES TRUE O FALSE, MOSTRAR EL BOTON DE RESPONDER EXAMEN O VER RESULTADOS
            $dosCompletado = false;
            if($nropreguntasrespondidasDos === $nropreguntasEvaluacionDos){
                $dosCompletado = true;
            }

            /////////////////////////////////////////////////////VALIDAR SI LA PRUEBA DE PRACTICA TIPO PT HA SIDO COMPLETADA

            //SE DEBE VALIDAR SI LA PRUEBA DE VISION TIPO PT HA SIDO RESPONDIDA TODAS SUS PREGUNTAS PARA SABER SI SE DEBE MOSTRAR EL BOTON DE INGRESAR AL EXAMEN O VER RESULTADOS

            //PRIMERO SE DEBE CONTAR EL NUMERO DE QUESTIONS ASIGNADAS A LA PRUEBA TIPO PT ASIGNADA AL USUARIO ACTUAL

            //EN LA VARIABLEE EVALUACIONPT SE CAPTURA LA PRUEBA PT ASIGNADA AL USUARIO ACTUAL, MEDIANTE LA COLECCION EVALUATIONS QUE CONTIENE LAS EVALUACIONS DE PRACTICA DEL USUARIO ACTUAL
            $evaluacionPT = $evaluationspractica->where('type', "PT");
            //EN LA VARIABLE EVALUACIONTRES SE CAPTURA EL PRIMER ELEMENTO DE LA COLECCION EVALUACIONPT
            $evaluacionTres = $evaluacionPT->first();
            //EN LA VARIABLE NROPREGUNTASEVALUACIONTRES SE CUENTA CUANTAS PREGUNTAS TIENE ESA PRUEBA
            $nropreguntasEvaluacionTres = count($evaluacionTres->questions);


            //AHORA SE DEBE CONTAR EL NUMERO DE PREGUNTAS RESPONDIDAS POR EL USUARIO A LA EVALUACIONTRES

            //EN LA VARIABLE PREGUNTASASIGNADASTRES SE VA A CAPTURAR LOS IDS DE LAS PREGUNTAS DE LA PRUEBA TRES ASIGNADA
            $preguntasasignadasTres = DB::table('questions')->where('evaluation_id', $evaluacionTres->id)->pluck('id')->toArray();
            //EN LA VARIABLE PREGUNTASRESPONDIDASTRES SE VA A CAPTURAR LA COLECCION DE PREGUNTAS QUE EL USUARIO HAYA RESPONDIDO Y QUE ESTEN EN LA TABLA RESULTS
            //QUE TENGAN EL MISMO EVALUATION_ID DE LA EVALUACION TRES, QUE TENGAN EL MISMO QUESTION_ID DE LAS PREGUNTAS DE LA EVALUACION TRES Y QUE TENGAN EL MISMO
            //USER_ID QUE EL USUARIO ACTUAL LOGEADO
            $preguntasrespondidasTres = DB::table('results')->where('evaluation_id', $evaluacionTres->id)->where('user_id', $authUser)->whereIn('question_id', $preguntasasignadasTres)->get();
            //COMO EN LA TABLA RESULTS SE ALMACENAN VARIAS RESPUESTAS SEGUN EL TIPO DE PREGUNTA, POR EJEMPLO LA QUESTION OM GUARDA 1 REGISTRO EN RESULTS, PERO LA QUESTION PC GUARDA 5 REGISTROS EN RESULTS
            //POR LO QUE DE LA COLECCION DE PREGUNTAS RESPONDIDAS QUE VIENE DESDE LA TABLA RESULTS SOLO SE CAPTURA LOS PRIMEROS ELEMENTOS CON QUESTION_ID DIFERENTES
            $resultadospreguntasTres = $preguntasrespondidasTres->unique('question_id')->values();
            //EN LA VARIABLE NROPREGUNTASRESPONDIDASTRES SE GUARDA EL NUMERO DE QUESTIONS RESPONDIDAS SEGUN LA TABLA RESULTS
            $nropreguntasrespondidasTres = count($resultadospreguntasTres);


            //AHORA, EN LA VARIABLE TRESCOMPLETADO QUE ES TIPO BOOLEAN SE ENVIA TRUE SI EL NUMERO DE QUESTIONS DEL EXAMEN TRES COINCIDE CON EL NUMERO DE QUESTIONS RESPONDIDAS
            //POR EL USUARIO QUE VIENE DE LA TABLA RESULTS, ESTO SIRVE PARA SEGUN SI ES TRUE O FALSE, MOSTRAR EL BOTON DE RESPONDER EXAMEN O VER RESULTADOS
            $tresCompletado = false;
            if($nropreguntasrespondidasTres === $nropreguntasEvaluacionTres){
                $tresCompletado = true;
            }


            //////////////////////////////////////////VALIDAR SI LA PRUEBA FINAL HA SIDO COMPLETADA

            //SE DEBE VALIDAR SI LA PRUEBA FINAL HA SIDO RESPONDIDA TODAS SUS PREGUNTAS PARA SABER SI SE DEBE MOSTRAR EL BOTON DE INGRESAR AL EXAMEN O VER RESULTADOS

            //PRIMERO SE DEBE CONTAR EL NUMERO DE QUESTIONS ASIGNADAS A LA PRUEBA FINAL ASIGNADA AL USUARIO ACTUAL

            //EN LA VARIABLE EVALUACIONFINAL SE CAPTURA LA PRUEBA FINAL ASIGNADA AL USUARIO ACTUAL, MEDIANTE LA COLECCION EVALUATIONS QUE CONTIENE LA EVALUACION FINAL ASIGNADA AL USUARIO ACTUAL
            $evaluacionFinal = $evaluations->first();
            //EN LA VARIABLE NROPREGUNTASEVALUACIONFINAL SE CUENTA CUANTAS PREGUNTAS TIENE ESA PRUEBA
            $nropreguntasEvaluacionFinal = count($evaluacionFinal->questions);

            //AHORA SE DEBE CONTAR EL NUMERO DE PREGUNTAS RESPONDIDAS POR EL USUARIO A LA EVALUACIONFINAL

            //EN LA VARIABLE PREGUNTASASIGNADASFINAL SE VA A CAPTURAR LOS IDS DE LAS PREGUNTAS DE LA PRUEBA FINAL ASIGNADA
            $preguntasasignadasFinal = DB::table('questions')->where('evaluation_id', $evaluacionFinal->id)->pluck('id')->toArray();
            //EN LA VARIABLE PREGUNTASRESPONDIDASFINAL SE VA A CAPTURAR LA COLECCION DE PREGUNTAS QUE EL USUARIO HAYA RESPONDIDO Y QUE ESTEN EN LA TABLA RESULTS
            //QUE TENGAN EL MISMO EVALUATION_ID DE LA EVALUACIONFINAL, QUE TENGAN EL MISMO QUESTION_ID DE LAS PREGUNTAS DE LA EVALUACION FINAL Y QUE TENGAN EEL MISMO
            //USER_ID QUE EL USUARIO ACTUAL LOGEADO
            $preguntasrespondidasFinal = DB::table('results')->where('evaluation_id', $evaluacionFinal->id)->where('user_id', $authUser)->whereIn('question_id', $preguntasasignadasFinal)->get();
            //COMO EN LA TABLA RESULTS SE ALMACENAN VARIAS RESPUESTAS SEGUN EL TIPO DE PREGUNTA, POR EJEMPLO LA QUESTION OM GUARDA 1 REGISTRO EN RESULTS, PERO LA QUESTION PC GUARDA 5 REGISTRSO EN RESULTS
            //POR LO QUE DE LA COLECCION DE PREGUNTAS RESPONDIDAS QUE VIENE DESDE LA TABLA RESULTS, SOLO SE CAPTURA LOS PRIMEROS ELEMENTOS CON QUESTION_ID DIFERENTES
            $resultadospreguntasFinal = $preguntasrespondidasFinal->unique('question_id')->values();
            //EN LA VARIABLE NROPREGUNTASRESPONDIDASFINAL SE GUARDA EL NUMERO DE QUESTIONS RESPONDIDAS SEGUN LA TABLA RESULTS
            $nropreguntasrespondidasFinal = count($resultadospreguntasFinal);


            //AHORA, EN LA VARIABLE FINALCOMPLETADO QUE ES TIPO BOOLEAN SE ENVIA TRUE SI EL NUMERO DE QUESTIONS DEL EXAMEN FINAL COINCIDE CON EL NUMERO DE QUESTIONS RESPONDIDAS
            //POR EL USUARIO, QUE VIENE DESDE LA TABLA RESULTS, ESTO SIRVE PARA SEGUN SI ES TRUE O FALSE, MOSTRAR EL BOTON DE RESPONDER EXAMEN O VER RESULTADOS
            $finalCompletado = false;
            if($nropreguntasrespondidasFinal === $nropreguntasEvaluacionFinal){
                $finalCompletado = true;
            }

            //return $finalCompletado;

            return view('rules.final', compact('evaluations', 'wasEvaluationCompleted', 'isEvaluationAssigned', 'diagnosticoCompletado', 'unoCompletado', 'dosCompletado', 'tresCompletado', 'finalCompletado'
                                                , 'diagnostico', 'evaluacionUno', 'evaluacionDos', 'evaluacionTres'));
            
        }else{
            return view('rules.final', compact('isEvaluationAssigned'));
        }


    }
    
}
